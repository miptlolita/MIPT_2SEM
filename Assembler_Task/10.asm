;Ответ: фактически программа всегда выводит четыре стадии и в конце, как результат число 30.
;На самом же деле программа выводит рекурсивную сумму 1*1+2*2+3*3+4*4=30.
;Подробнее читай примечания.

	extern	printf	                    ;Экспортируем фунцкию "printf" языка C.

	section .data                       ;Начало секции данных.
fmt:	db	'Stage = %d', 10, 0         ;Строка формата вывода. (Делает так, чтобы выводилась не просто чиселка, а надпись с чиселкой)
resfmt:	db	'Res = %d', 10, 0           ;Строка формата вывода. (Делает так, чтобы выводилась не просто чиселка, а надпись с чиселкой)

	section .text                       ;Начало секции исходного кода.

	global main                         ;Обьявляем метку main глобальной.

main:                                   ;Обьявляем метку main.
	push	4                           ;Кидаем в стек число 4.
	call	recursion                   ;Вызываем часть кода по метке "recursion".
	add	esp, 4                          ;Чистим после себя стек, убирая добавленное ранее число.(*)
	push	dword eax                   ;Кидаем в стек значение из регистра eax, предварительно приведя к численному типу.
	push	resfmt                      ;Кидаем в стек строку формата вывода.
	call	printf                      ;Вызываем функцию printf.
	add	esp, 8                          ;Чистим после себя стек, удаляя 8/4=2 чиселки.
	mov	eax,0                           ;В регистр eax кладём число 0.
	ret                                 ;Выполняем возврат из процедуры, вызванной call.

recursion:                              ;Обьявляем метку recursion.
        mov     eax, [esp+4]            ;Складываем в eax верхнее значение стека. (Оно у нас в начале равно 4)
	push	eax                         ;Кидаем в стек значение eax.
	push	dword eax                   ;Туда же значение eax, приведённое к численному типу.
	push	fmt                         ;Кидаем в стек строку формата.
	call	printf                      ;Вызываем функцию printf.
	add	esp, 8                          ;Чистим после себя стек, удаляя 8/4=2 чиселки (точнее значения).
	pop	eax                             ;Забираем eax из стека.
        cmp	eax, 1                      ;Если eax = 1.
        jnle	L1                      ;Jump if not less or equal  - прыгает на метку L1 если в eax единичка, или меньше.
        mov	eax, 1                      ;В регистр eax записываем значение 1.
        jmp	L2                          ;Прыгаем в L2.
L1:                                     ;Обьявляем метку L1.
	dec	eax                             ;Уменьшаем значение в регистре eax на единицу.
	push	eax                         ;Кидаем в стек значение eax.
	call	recursion                   ;Вызываем часть кода по метке recursion.
	add	esp, 4                          ;Чистим после себя стек, удаляя чиселку.
	mov	ebx, eax                        ;Кидаем в регистр ebx значение регистра eax.
	mov	eax, [esp+4]                    ;Кидаем в eax значение из стека 
	imul	eax, eax                    ;Умножаем 4*4=16 3*3=9 2*2=4 1*1=1.
	add	eax, ebx                        ;Добавляем к eax ebx, потом выводим на экран, согласно технологии возврата из call.(*)
L2:                                     ;Обьявляем метку L2.
	ret                                 ;Возврат из процедуры, вызванной call.
	
;Примечания:
; 1) Возврат из call recursion осуществляется по (*).
; 2) Данный вариант является самым сложным. 
; 3) Программа представляет собой сложную рекурсию в ходе которой чиселка 4 умножается сама на себя и к ней прибавляется на выходе результат тех же операций для 4-1=3. Так далее.

